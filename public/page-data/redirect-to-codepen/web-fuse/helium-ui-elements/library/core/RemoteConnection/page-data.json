{"componentChunkName":"component---node-modules-gatsby-remark-code-repls-default-redirect-template-js","path":"/redirect-to-codepen/web-fuse/helium-ui-elements/library/core/RemoteConnection","webpackCompilationHash":"","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"action":"https://codepen.io/pen/define","payload":"{\"editors\":\"0010\",\"html\":\"<div id=\\\"root\\\"></div>\",\"js\":\"import { MCError } from './MCError.js';\\n\\nexport class RemoteConnection {\\n    constructor (serviceUrls, headers) {\\n        this._serviceUrls = serviceUrls;\\n        this._headers = headers || {};\\n        this._unhandledError = new MCError({\\n            status: -1,\\n            responseText: JSON.stringify({ code: 'NoServerConnection', errors: ['not connected to server'] })\\n        });\\n    }\\n\\n    getURL (service) {\\n        return this._serviceUrls.getURL(service);\\n    }\\n\\n    hostname () {\\n        return this._serviceUrls.hostname();\\n    }\\n\\n    async getfile (service, path) {\\n        return new Promise((resolve, reject) => {\\n            let that = this;\\n            let url = this.getURL(service);\\n            let xhttp = new XMLHttpRequest();\\n            xhttp.responseType = 'blob';\\n            xhttp.onreadystatechange = () => {\\n                if (xhttp.readyState === 4) {\\n                    let status = xhttp.status;\\n                    if (status < 200 || status >= 300) {\\n                        reject(new MCError({\\n                            status: status,\\n                            body: xhttp.response\\n                        }));\\n                    } else {\\n                        resolve({\\n                            status: status,\\n                            body: xhttp.response\\n                        });\\n                    }\\n                }\\n            };\\n\\n            xhttp.onerror = () => {\\n                reject(that._unhandledError);\\n            };\\n\\n            xhttp.open('GET', url + path, true);\\n            this._addHeaders(xhttp);\\n            xhttp.send();\\n        });\\n    }\\n\\n    async get (service, path, filter, start, end) {\\n        return new Promise((resolve, reject) => {\\n            let that = this;\\n            let url = this.getURL(service);\\n            let xhttp = new XMLHttpRequest();\\n            xhttp.onreadystatechange = () => {\\n                if (xhttp.readyState === 4) {\\n                    let status = xhttp.status;\\n                    if (status < 200 || status >= 300) {\\n                        reject(new MCError({\\n                            status: status,\\n                            responseText: xhttp.responseText\\n                        }));\\n                    } else {\\n                        resolve({\\n                            status: status,\\n                            responseText: xhttp.responseText,\\n                            headers: this._parseHeaders(xhttp.getAllResponseHeaders())\\n                        });\\n                    }\\n                }\\n            };\\n\\n            xhttp.onerror = () => {\\n                reject(that._unhandledError);\\n            };\\n\\n            if (!filter) {\\n                filter = {};\\n            }\\n            if ((end - start) > 0) {\\n                filter.skip = start;\\n                filter.take = end - start;\\n            }\\n            let queryString = this._toQueryString(filter);\\n\\n            xhttp.open('GET', url + path + queryString, true);\\n            this._addHeaders(xhttp);\\n            xhttp.setRequestHeader('Content-type', 'application/json');\\n            xhttp.send();\\n        });\\n    }\\n\\n    async post (service, path, json) {\\n        return this._postType(service, path, json, 'application/json');\\n    }\\n\\n    async postfile (service, path, file) {\\n        return this._postType(service, path, file, 'application/octet-stream');\\n    }\\n\\n    async _postType (service, path, data, contentType) {\\n        return new Promise((resolve, reject) => {\\n            let that = this;\\n            let url = this.getURL(service);\\n            let xhttp = new XMLHttpRequest();\\n            xhttp.onreadystatechange = () => {\\n                if (xhttp.readyState === 4) {\\n                    let status = xhttp.status;\\n                    if (status < 200 || status >= 300) {\\n                        reject(new MCError({\\n                            status: status,\\n                            responseText: xhttp.responseText\\n                        }));\\n                    } else {\\n                        resolve({\\n                            status: status,\\n                            responseText: xhttp.responseText,\\n                            headers: this._parseHeaders(xhttp.getAllResponseHeaders())\\n                        });\\n                    }\\n                }\\n            };\\n\\n            xhttp.onerror = () => {\\n                reject(that._unhandledError);\\n            };\\n\\n            xhttp.open('POST', url + path, true);\\n            this._addHeaders(xhttp);\\n            if (!(data instanceof FormData)) {\\n                xhttp.setRequestHeader('Content-type', contentType);\\n            }\\n            xhttp.send(data);\\n        });\\n    }\\n\\n    async delete (service, path) {\\n        return new Promise((resolve, reject) => {\\n            let that = this;\\n            let url = this.getURL(service);\\n            let xhttp = new XMLHttpRequest();\\n            xhttp.onreadystatechange = () => {\\n                if (xhttp.readyState === 4) {\\n                    let status = xhttp.status;\\n                    if (status < 200 || status >= 300) {\\n                        reject(new MCError({\\n                            status: status,\\n                            responseText: xhttp.responseText\\n                        }));\\n                    } else {\\n                        resolve({\\n                            status: status,\\n                            responseText: xhttp.responseText,\\n                            headers: this._parseHeaders(xhttp.getAllResponseHeaders())\\n                        });\\n                    }\\n                }\\n            };\\n\\n            xhttp.onerror = () => {\\n                reject(that._unhandledError);\\n            };\\n\\n            xhttp.open('DELETE', url + path, true);\\n            this._addHeaders(xhttp);\\n            xhttp.setRequestHeader('Content-type', 'application/json');\\n            xhttp.send();\\n        });\\n    }\\n\\n    async put (service, path, json) {\\n        return this._putType(service, path, json, 'application/json');\\n    }\\n\\n    async putfile (service, path, file) {\\n        return this._putType(service, path, file, 'application/octet-stream');\\n    }\\n\\n    async _putType (service, path, data, contentType) {\\n        return new Promise((resolve, reject) => {\\n            let that = this;\\n            let url = this.getURL(service);\\n            let xhttp = new XMLHttpRequest();\\n            xhttp.onreadystatechange = () => {\\n                if (xhttp.readyState === 4) {\\n                    let status = xhttp.status;\\n                    if (status < 200 || status >= 300) {\\n                        reject(new MCError({\\n                            status: status,\\n                            responseText: xhttp.responseText\\n                        }));\\n                    } else {\\n                        resolve({\\n                            status: status,\\n                            responseText: xhttp.responseText,\\n                            headers: this._parseHeaders(xhttp.getAllResponseHeaders())\\n                        });\\n                    }\\n                }\\n            };\\n\\n            xhttp.onerror = () => {\\n                reject(that._unhandledError);\\n            };\\n\\n            xhttp.open('PUT', url + path, true);\\n            this._addHeaders(xhttp);\\n            if (!(data instanceof FormData)) {\\n                xhttp.setRequestHeader('Content-type', contentType);\\n            }\\n            xhttp.send(data);\\n        });\\n    }\\n\\n    _addHeaders (xhttp) {\\n        for (let key in this._headers) {\\n            if (this._headers.hasOwnProperty(key)) {\\n                xhttp.setRequestHeader(key, this._headers[key]);\\n            }\\n        }\\n    }\\n\\n    _parseHeaders (allResponseHeaders) {\\n        let splitHeaders = allResponseHeaders.split('\\\\r\\\\n');\\n        return splitHeaders.reduce(function (acc, current) {\\n            let parts = current.split(': ');\\n            acc[parts[0]] = parts[1];\\n            return acc;\\n        }, {});\\n    }\\n\\n    _toQueryString (filter) {\\n        let queryString = Object.keys(filter)\\n            .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(filter[key]))\\n            .join('&');\\n        if (queryString !== '') {\\n            queryString = '?' + queryString;\\n        }\\n        return queryString;\\n    }\\n}\\n\",\"js_external\":\"\",\"js_pre_processor\":\"babel\",\"layout\":\"left\"}"}}}