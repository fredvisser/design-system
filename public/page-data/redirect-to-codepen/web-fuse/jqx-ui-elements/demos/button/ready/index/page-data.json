{"componentChunkName":"component---node-modules-gatsby-remark-code-repls-default-redirect-template-js","path":"/redirect-to-codepen/web-fuse/jqx-ui-elements/demos/button/ready/index","webpackCompilationHash":"","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"action":"https://codepen.io/pen/define","payload":"{\"editors\":\"0010\",\"html\":\"<div id=\\\"root\\\"></div>\",\"js\":\"var NationalInstruments = {};\\nNationalInstruments.JQXElement = { Elements: [] };\\n// ****************************************\\n// Custom Element Extensions\\n// ****************************************\\n(function () {\\n    'use strict';\\n    // Static Private Reference Aliases\\n\\n    // The list of jqx elements that we support along with their element info\\n    var _elements = [];\\n    _elements.push({ tagName: 'jqx-numeric-text-box', propertyName: 'value', attributeName: 'value', eventName: 'change', isTextEditFocusable: true });\\n    _elements.push({ tagName: 'jqx-progress-bar', propertyName: 'value', attributeName: 'value', eventName: '', isTextEditFocusable: false });\\n    _elements.push({ tagName: 'jqx-circular-progress-bar', propertyName: 'value', attributeName: 'value', eventName: '', isTextEditFocusable: false });\\n    _elements.push({ tagName: 'jqx-tank', propertyName: 'value', attributeName: 'value', eventName: 'change', isTextEditFocusable: false });\\n    _elements.push({ tagName: 'jqx-slider', propertyName: 'value', attributeName: 'value', eventName: 'change', isTextEditFocusable: false });\\n    _elements.push({ tagName: 'jqx-button', propertyName: 'value', attributeName: 'value', eventName: 'change', isTextEditFocusable: false });\\n\\n    var create = function (element, elementInfo) {\\n        var bindingInfo;\\n\\n\\n        // update internal properties from attribute values\\n\\n        Object.defineProperty(element, 'isTextEditFocusable', {\\n            configurable: false,\\n            enumerable: false,\\n            writable: false,\\n            value: function () {\\n                return elementInfo.isTextEditFocusable;\\n            }\\n        });\\n        Object.defineProperty(element, 'setFont', {\\n            configurable: false,\\n            enumerable: false,\\n            writable: false,\\n            value: function (fontSize, fontFamily, fontWeight, fontStyle, textDecoration) {\\n                this.style.fontSize = fontSize;\\n                this.style.fontFamily = fontFamily;\\n                this.style.fontWeight = fontWeight;\\n                this.style.fontStyle = fontStyle;\\n                this.style.textDecoration = textDecoration;\\n            }\\n        });\\n    };\\n\\n    var attach = function (element) {\\n        if (!element.firstAttach) {\\n            element.firstAttach = true;\\n            return;\\n        }\\n\\n        // this is for reparenting. Properties set in attach will not be applied to the elements appearance\\n        // (but during reparenting they are not changing anyway)\\n        setup(element);\\n    };\\n\\n    var ready = function (element) {\\n        element.firstAttach = false;\\n        // this is for first time setup - the properties set here will be applied to the elements appearance\\n        setup(element);\\n\\n    };\\n\\n\\n\\n\\n    var setup = function (element) {\\n        element.model = { clickMode: 'release', value: \\\"Value\\\", contentVisible: true, glyph: \\\"\\\", content: \\\"Text\\\" };\\n        var counter = 0;\\n        element.addEventListener('click', function () {\\n            element.model = { clickMode: 'press', value: \\\"Value\\\", contentVisible: true, glyph: \\\"\\\", content: \\\"Text\\\" + counter++ };\\n            element.updateContent();\\n        });\\n\\n        element.createContent();\\n        element.updateContent();\\n\\n        element.clickMode = element.model.clickMode;\\n        element.value = element.model.value.toString();\\n    };\\n\\n    var detach = function (element) {\\n\\n    };\\n\\n    var addProperties = function (proto, tagName) {\\n\\n        Object.defineProperty(proto, 'elementInfo', {\\n            configurable: false,\\n            enumerable: true,\\n            value: { tagName: tagName, valuePropertyDescriptor: { propertyName: '', attributeName: '', eventName: '', propertyNameNonSignaling: '' } },\\n            writable: true\\n        });\\n    };\\n\\n    // Extensions to multiple prototypes\\n    var toReg;\\n\\n    var handleRegistered = function (proto, elementInfo) {\\n        addProperties(proto, elementInfo.tagName);\\n        proto.onCreated = function () {\\n            if (this.tagName === elementInfo.tagName.toUpperCase()) {\\n                create(this, elementInfo);\\n            }\\n        };\\n\\n        proto.onReady = function () {\\n            if (this.tagName === elementInfo.tagName.toUpperCase()) {\\n                ready(this);\\n            }\\n        };\\n\\n        proto.onAttached = function () {\\n            if (this.tagName === elementInfo.tagName.toUpperCase()) {\\n                attach(this);\\n            }\\n        };\\n\\n        proto.onDetached = function () {\\n            if (this.tagName === elementInfo.tagName.toUpperCase()) {\\n                detach(this);\\n            }\\n        };\\n\\n        proto.createContent = function () {\\n            var childElement = this.firstElementChild;\\n            if (childElement) {\\n                childElement.innerHTML = '';\\n                var glyphDiv = document.createElement('div');\\n                glyphDiv.classList.add('ni-glyph');\\n                childElement.appendChild(glyphDiv);\\n                var contentSpan = document.createElement('span');\\n                contentSpan.classList.add('ni-text');\\n                childElement.appendChild(contentSpan);\\n            }\\n        };\\n\\n        proto.updateContent = function () {\\n            this.createContent();\\n            var childElement = this.firstElementChild;\\n            var glyphDiv = childElement.childNodes[0];\\n            var contentSpan = childElement.childNodes[1];\\n            contentSpan.textContent = this.model.content;\\n            glyphDiv.textContent = String.fromCharCode(this.model.glyph);\\n            if (this.model.contentVisible === true) {\\n                if (this.model.glyph !== 0) {\\n                    glyphDiv.style.display = 'inline';\\n                } else {\\n                    glyphDiv.style.display = 'none';\\n                }\\n\\n                contentSpan.style.display = 'inline';\\n            } else {\\n                glyphDiv.style.display = 'none';\\n                contentSpan.style.display = 'none';\\n            }\\n        };\\n    };\\n\\n    var whenRegistered = function (elementInfo) {\\n        window.JQX.Elements.whenRegistered(elementInfo.tagName, function (proto) {\\n            handleRegistered(proto, elementInfo);\\n        });\\n    };\\n\\n    for (toReg in _elements) {\\n        if (_elements.hasOwnProperty(toReg)) {\\n            whenRegistered(_elements[toReg]);\\n        }\\n    }\\n\\n    NationalInstruments.JQXElement._registerElements = function () {\\n        window.JQX.Elements.registerElements();\\n    };\\n\\n}());\\n\",\"js_external\":\"\",\"js_pre_processor\":\"babel\",\"layout\":\"left\"}"}}}